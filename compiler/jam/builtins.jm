
#TODO: Allow for arbitrary sizes
class Int
  value:_builtins.Int64

  new()
    value = 0.value
  end

  new(v:_builtins.Int64)
    value = v
  end

  def self + other:Int
    return Int(_builtins.intAdd(value, other.value))
  end

  def +self
    return Int(value)
  end

  def self - other:Int
    return Int(_builtins.intSub(value, other.value))
  end

  def -self
    zero = 0
    return Int(_builtins.intSub(zero.value, value))
  end

  def self * other:Int
    return Int(_builtins.intMul(value, other.value))
  end

  def self // other:Int
    return Int(_builtins.intDiv(value, other.value))
  end

  def self % other:Int
    return Int(_builtins.intRem(value, other.value))
  end

  def self == other:Int
    return Bool(_builtins.intEqual(value, other.value))
  end

  def self != other:Int
    return Bool(_builtins.intUnequal(value, other.value))
  end

  def self > other:Int
    return Bool(_builtins.intGreaterThan(value, other.value))
  end

  def self >= other:Int
    return Bool(_builtins.intGreaterOrEqualTo(value, other.value))
  end

  def self < other:Int
    return Bool(_builtins.intSmallerThan(value, other.value))
  end

  def self <= other:Int
    return Bool(_builtins.intSmallerOrEqualTo(value, other.value))
  end

  def self as Real
    return Real(_builtins.Int64ToFloat64(value))
  end
end

class Int8
  value:_builtins.Int8
end

#TODO: Allow for arbitrary sizes
class Real
  value:_builtins.Float64

  new()
    value = 0.0.value
  end

  new(v:_builtins.Float64)
    value = v
  end

  def self + other:Real
    return Real(_builtins.floatAdd(value, other.value))
  end

  def self - other:Real
    return Real(_builtins.floatSub(value, other.value))
  end

  def -self
    zero = 0.0
    return Real(_builtins.floatSub(zero.value, value))
  end

  def self * other:Real
    return Real(_builtins.floatMul(value, other.value))
  end

  def self / other:Real
    return Real(_builtins.floatDiv(value, other.value))
  end

  def self % other:Real
    return Real(_builtins.floatRem(value, other.value))
  end

  def self > other:Real
    return Bool(_builtins.floatGreaterThan(value, other.value))
  end

  def self >= other:Real
    return Bool(_builtins.floatGreaterOrEqualTo(value, other.value))
  end

  def self < other:Real
    return Bool(_builtins.floatSmallerThan(value, other.value))
  end

  def self <= other:Real
    return Bool(_builtins.floatSmallerOrEqualTo(value, other.value))
  end

  def self as Int
    return Int(_builtins.Float64ToInt64(value))
  end
end

#TODO: Implement using byte arrays
class String
  value:_builtins.String

  new()
    value = "".value
  end

  new(v:_builtins.String)
    value = v
  end
end

#TODO: Implement properly
class Bool
  value:_builtins.Bool

  new()
    value = false.value
  end

  new(v:_builtins.Bool)
    value = v
  end

  def !self
    #TODO: Get rid of branching here
    if Bool(value)
      return false
    end
    return true
  end

  def self as String
    if Bool(value)
      return "true"
    else
      return "false"
    end
  end
end

#TODO: Implement properly once casting is in place
def print(value:Int)
  _builtins.print(value.value)
end

def print(value:Real)
  _builtins.print(value.value)
end

def print(value:Bool)
  print(value as String)
end

def print(value:String)
  _builtins.print(value.value)
end

def puts(value:Int)
  print(value)
  print("\n")
end

def puts(value:Real)
  print(value)
  print("\n")
end

def puts(value:Bool)
  puts(value as String)
end

def puts(value:String)
  print(value)
  print("\n")
end

module math
  def max(a, b)
    if a > b
      return a
    else
      return b
    end
  end

  def min(a, b)
    if a < b
      return a
    else
      return b
    end
  end
end

module memory
  pragma def Ptr(T)
    class ptr
      pointer:_builtins.Void

      new()
      end

      new(value:_builtins.Void)
        pointer = value
      end

      def get() -> T
        return pointer
      end

      def set(e:T)
        pointer = e
      end

      def alloc(size:Int)
        size = size * sizeOf(T)
        pointer = _builtins.alloc(size.value)
      end

      def realloc(size:Int)
        size = size * sizeOf(T)
        return ptr(_builtins.realloc(pointer, size.value))
      end

      def self + other:Int
        offset = other * sizeOf(T)
        return ptr(_builtins.ptrOffset(pointer, offset.value))
      end
    end

    return ptr
  end
end

pragma def Array(Element)
  class Header
    length:Int
    capacity:Int

    new(l, c)
      length = l
      capacity = c
    end
  end

  class array
    pointer:pragma memory.Ptr(Int8)

    new()
      pointer.alloc(sizeOf(Header) + 4 * sizeOf(Element))
      setHeader(Header(0, 4))
    end

    new(len:Int)
      head = Header(len, math.max(len, 4))
      pointer.alloc(sizeOf(Header) + head.capacity * sizeOf(Element))
      setHeader(head)
    end

    def get(index:Int) -> Element
      return (dataPtr() + index).get()
    end

    def set(index:Int, element:Element)
      (dataPtr() + index).set(element)
    end

    def add(element:Element)
      index = length()
      lengthChange(length() + 1)
      set(index, element)
    end

    def length()
      return header().length
    end

    # private
    def lengthChange(newLength:Int)
      head = header()
      head.length = newLength

      if head.length > head.capacity
        head.capacity = head.capacity * 2
        pointer = pointer.realloc(sizeOf(Header) + head.capacity * sizeOf(Element))
      end

      setHeader(head)
    end

    # private
    def header() -> Header
      return headPtr().get()
    end

    # private
    def setHeader(head:Header)
      headPtr().set(head)
    end

    # private
    def dataPtr() -> pragma memory.Ptr(Element)
      offset = pointer + sizeOf(Header)
      return (pragma memory.Ptr(Element))(offset.pointer)
    end

    # private
    def headPtr()
      return (pragma memory.Ptr(Header))(pointer.pointer)
    end

    def dup() -> array
      out = array(length())

      i = 0
      while i < length()
        out.set(i, get(i))
        i = i + 1
      end

      return out
    end

    def self + other:array
      out = array(length() + other.length())

      si = 0
      oi = 0
      index = 0
      while si < length()
        out.set(index, get(si))
        si = si + 1
        index = index + 1
      end
      while oi < other.length()
        out.set(index, other.get(oi))
        oi = oi + 1
        index = index + 1
      end

      return out
    end
  end

  return array
end

pragma def Range(T)
  class range
    start:T
    stop:T
    step:T

    new(stop_:T)
      start = 0
      stop = stop_
      step = 1
    end

    new(start_:T, stop_:T)
      start = start_
      stop = stop_
      step = 1
    end

    new(start_:T, stop_:T, step_:T)
      start = start_
      stop = stop_
      step = step_
    end

    def each(fn)
      x = start
      while x < stop
        fn(x)
        x = x + step
      end
    end

    # def each(fn)
    #   each(i => fn())
    # end

    def self as (pragma Array(T))
      out = ref (pragma Array(T))()

      def result(x:T)
        out.add(x)
      end
      each(result)

      return out
    end
  end

  return range
end
